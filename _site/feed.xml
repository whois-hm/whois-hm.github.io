<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>API Document</title>
    <description>^_^</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 28 Jul 2020 17:58:29 +0900</pubDate>
    <lastBuildDate>Tue, 28 Jul 2020 17:58:29 +0900</lastBuildDate>
    <generator>Jekyll v3.8.6</generator>
    
      <item>
        <title>NetGroup</title>
        <description>&lt;h2 id=&quot;1intro&quot;&gt;#1Intro&lt;/h2&gt; &lt;p&gt;프로젝트를 진행할때 가장 중요한것은 “구조설계”이다. Framework는 이 구조설계의 기반이 되며, 작성될 코드의 방향을 제시한다. 여러 Opensource에서 Framework를 제공하기 때문에 우리는 진행할 프로젝트의 컨셉에 맞는 Framework를 선정하거나 선정된 Framework를 Customize하여 사용하기도 하고, 때론 직접 제작하여 사용하기도 한다. 이번 Post에서는 “NetGroup”이라는 직접 만들어본 Event Report Framework를 소개해 보고자 한다.&lt;/p&gt; &lt;h2 id=&quot;2-whats-netgroup&quot;&gt;#2 What’s NetGroup&lt;/h2&gt; &lt;p&gt;“NetGroup”이란 무엇인가? 간단히 말하자면 Thread, Process간의 Communication Group이며 여기에 Network 개념을 도입하여, Unicast, BroadCast, Multicast 방식으로 Event를 송/수신하여 원하는 동작을 수행시킬수 있도록 하는 Framework이다.&lt;/p&gt; &lt;p&gt;이 Framework는 각 기능단위별 모듈을 “Host”라 칭하는 Thread로 생성하며, 이러한 “Host”들은 Router라는 한개의 단위에 등록되어 Thread간 Event 송수신이 가능한 Network Group을 이룰수 있도록하고,...</description>
        <pubDate>Tue, 28 Jul 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/netgroup-framework/</link>
        <guid isPermaLink="true">http://localhost:4000/netgroup-framework/</guid>
        
        
      </item>
    
      <item>
        <title>Aboute Livemedia</title>
        <description>&lt;h2 id=&quot;1intro&quot;&gt;#1Intro&lt;/h2&gt; &lt;p&gt;이 Repository는 “Media Player”를 구현하기위한 개인 Study Project이다. 목적은 단순 “Media Player”이지만 이를 시작하게 된 계기는 정말 다양하다.&lt;/p&gt; &lt;p&gt;c/c++ STL, MultiThread기반 설계, &lt;a href=&quot;http://whois-hm.github.io/about-workqueue/&quot;&gt;Workqueue 내용 증명,&lt;/a&gt; SystemResource처리, Class Design, 주 업무 이해도를 높이기 위한 Audio/Video IO, Muxing / DeMuxing등 을 학습하며, 개인 Skill up과 동시에 산출물을 얻기 위함이다.&lt;/p&gt; &lt;p&gt;주 언어는 c/c++ STL에 기반하여 설계하였고, 그렇기때문에 별도의 Library가아닌 Process에서 직접 기능단위별 Access가 가능하도록 Header에 내용을 담았다.&lt;/p&gt; &lt;p&gt;Project의 목적이 “Media”이므로 &lt;br /&gt; Codec, En/Decoder, Muxer/DeMuxer등은 &lt;a href=&quot;https://www.ffmpeg.org/&quot;&gt;FFMPEG&lt;/a&gt;&lt;br /&gt; NetWork Streaming(RTSP)는 &lt;a href=&quot;http://www.live555.com/&quot;&gt;Live555&lt;/a&gt;&lt;br /&gt; GUI Display는 Desktop &lt;a href=&quot;https://www.libsdl.org/&quot;&gt;SDL2&lt;/a&gt;, Embedded &lt;a href=&quot;https://github.com/whois-hm/am335x&quot;&gt;Beaglebone Black&lt;/a&gt;&lt;br /&gt; 을 사용하였다.&lt;/p&gt; &lt;h2 id=&quot;2class-simple-diagram&quot;&gt;#2Class Simple Diagram&lt;/h2&gt; &lt;p&gt;&lt;img...</description>
        <pubDate>Mon, 27 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/aboute-livemedia/</link>
        <guid isPermaLink="true">http://localhost:4000/aboute-livemedia/</guid>
        
        
      </item>
    
      <item>
        <title>Heap Manage</title>
        <description>&lt;h2 id=&quot;1-intro&quot;&gt;#1 Intro&lt;/h2&gt; &lt;p&gt;우리가 만든 프로그램은 구동시 또는 RunTime에 Os에 의한 자원할당, 필요한 자원을 요청하면서 작업을 수행한다.&lt;/p&gt; &lt;p&gt;이번 Post에선 이러한 Os에서 제공되는 Memory영역의 OS / Stack / Data / Heap중 “Heap 영역”에 관한 내용을 정리하면서, 사용에 있어 발생할 수 있는 Exception 과 해결하는 방안도 함께 알아보고자 한다.&lt;/p&gt; &lt;table width=&quot;300&quot; height=&quot;100&quot;&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;Os&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;Data&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;Stack&lt;/td&gt; &lt;/tr&gt; &lt;tr align=&quot;center&quot; bgcolor=&quot;#41AF39&quot;&gt; &lt;td&gt;Heap&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;h2 id=&quot;2-heap&quot;&gt;#2 Heap&lt;/h2&gt; &lt;p&gt;Heap Memory는 필요에 의해 “동적할당”이 이뤄지는 영역이다.&lt;/p&gt; &lt;p&gt;다시말해 Runtime시 특정자료를 보관하기 위한 “사용자 Memory”이며, Os는 각 Process마다 특정 크기의 Heap Memory를 Virtual Memory형태로 제공하기 때문에 우리는 필요에 따라 원하는...</description>
        <pubDate>Fri, 24 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/heap-manage/</link>
        <guid isPermaLink="true">http://localhost:4000/heap-manage/</guid>
        
        
      </item>
    
      <item>
        <title>Workqueue API</title>
        <description>&lt;h2 id=&quot;1-intro&quot;&gt;#1 Intro&lt;/h2&gt; &lt;p&gt;“About Workqueue” Post에 적용되는 api와, 기타 Utility api를 제공하는 Library 소개. &lt;br /&gt;&lt;/p&gt; &lt;h2 id=&quot;2-first-thing-to-know&quot;&gt;#2 First thing To Know&lt;/h2&gt; &lt;p&gt;Library는 Os 종속 없이 Windows / Linux 모두 Porting이 가능하도록 개발될 예정이며 현재는 Linux 기반에서만 Porting이 되어있다.&lt;/p&gt; &lt;h4 id=&quot;repository---------------httpsgithubcomwhois-hmworkqueue&quot;&gt;Repository &lt;a href=&quot;https://github.com/whois-hm/workqueue&quot;&gt;https://github.com/whois-hm/workqueue&lt;/a&gt;&lt;/h4&gt; &lt;h4 id=&quot;workqueue란------about-workqueue&quot;&gt;Workqueue란 ? &lt;a href=&quot;https://whois-hm.github.io/about-workqueue&quot;&gt;about workqueue&lt;/a&gt;&lt;/h4&gt; &lt;h3 id=&quot;heap관리---------------heap-manage&quot;&gt;Heap관리 &lt;a href=&quot;https://whois-hm.github.io//heap-manage&quot;&gt;heap manage&lt;/a&gt;&lt;/h3&gt; &lt;h2 id=&quot;3description&quot;&gt;#3Description&lt;/h2&gt; &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;-------------------------------------------------------------------------------------------&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* Des : Workqueue를 생성한다. Param size : 사용할 Event의 최대 크기(Queue Element Size) Param length : Queue의 갯수 Return : 생성 성공시 HANDLE 실패시 NULL */&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-------------------------------------------------------------------------------------------&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;WQ_API&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;WQ&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span...</description>
        <pubDate>Thu, 23 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/workqueue-api/</link>
        <guid isPermaLink="true">http://localhost:4000/workqueue-api/</guid>
        
        
      </item>
    
      <item>
        <title>About  Workqueue</title>
        <description>&lt;h2 id=&quot;1-thread&quot;&gt;#1 Thread&lt;/h2&gt; &lt;p&gt;Process를 설계하다보면, 실시간처리, Blocking I/O처리, 단일Context등의 관리를 위해 Thread를 사용한 병렬처리를 요구하는 경우가 발생한다.&lt;/p&gt; &lt;blockquote&gt; &lt;p&gt;Thread가 요구되는 간단한 예&lt;/p&gt; &lt;/blockquote&gt; &lt;p&gt;&lt;img src=&quot;../images/audiofile_speaker.png&quot; alt=&quot;audiofile_speaker&quot; /&gt;&lt;/p&gt; &lt;p&gt;프로그램이 구동되면 하나의 오디오 파일에서 2개의 출력 장치로 Sound를 출력하는 아래의 예시 코드를 보자&lt;/p&gt; &lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;open_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read_file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write_audio1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write_audio2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt; &lt;p&gt;진입점에서 오디오파일을 열고 파일의 데이터를 전부 읽을때까지 while루프 안에서 1번, 2번...</description>
        <pubDate>Tue, 21 Apr 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/about-workqueue/</link>
        <guid isPermaLink="true">http://localhost:4000/about-workqueue/</guid>
        
        
      </item>
    
      <item>
        <title>Smart Pointer</title>
        <description>&lt;h2 id=&quot;1-intro&quot;&gt;#1 Intro&lt;/h2&gt; &lt;p&gt;우리는 &lt;a href=&quot;https://github.com/whois-hm/heap-manage&quot;&gt;여기서&lt;/a&gt; Virtual Memory를 요청하고 반환받아 User 영역에서 사용되는 Heap Memory라는 개념을 알아봄과 동시에 항상 요청/해지, 즉 사용을 완료한 Block은 다시 반환하여 다시 가용가능한 Block으로 만들어줘함을 확인하였다. 보통 Block을 생성한 주체가 이에 대한 해지의 책임을 가져가는것이 일반적이지만, n개의 Thread를 사용하게 되고, 서로 관계를 갖기 시작하면서 Free Point가 애매모호 해지거나, 경우에 따라 거대한 Block을 운영하는 경우 운영방법 따라 메모리 효율성이 떨어질 가능성이 존재한다. 이번 Post 에선 위에서 말한&lt;/p&gt; &lt;h4 id=&quot;1ambiguous-free-point&quot;&gt;1.Ambiguous Free Point&lt;/h4&gt; &lt;h4 id=&quot;2메모리-효율성&quot;&gt;2.메모리 효율성&lt;/h4&gt; &lt;p&gt;에 대한 예를 돌어보면서 이를 해결해 나아가는 방법을 알아가보고자 한다.&lt;/p&gt; &lt;h2 id=&quot;2--occurrence-case&quot;&gt;#2 Occurrence Case&lt;/h2&gt; &lt;p&gt;한가지 프로세스를 만든다 가정해보자. 이 프로세스는 한개의 Pixel...</description>
        <pubDate>Mon, 27 Jan 2020 00:00:00 +0900</pubDate>
        <link>http://localhost:4000/smartpointer/</link>
        <guid isPermaLink="true">http://localhost:4000/smartpointer/</guid>
        
        
      </item>
    
  </channel>
</rss>
